/**
 * @file Overview
 * This ruleset enforces a strict user-ownership model for user profiles and a shared access model for other collections.
 *
 * Data Structure:
 * - User profiles are stored under `/users/{userId}`, ensuring only the authenticated user can access their own profile.
 * - Game sessions, courts, and groups are stored in top-level collections: `/gameSessions/{gameSessionId}`, `/courts/{courtId}`, and `/groups/{groupId}`, respectively.
 *
 * Key Security Decisions:
 * - User listing is explicitly denied.
 * - Data validation is limited to authorization-critical fields to allow for rapid prototyping.
 * - For shared access, documents contain arrays of user IDs (`memberIds`, `playerIds`, etc.) to control access.
 *
 * Denormalization for Authorization:
 * - Game sessions denormalize the `organizerId` to allow direct authorization checks without additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user profiles, ensuring only the authenticated user can access their own profile.
     * @path /users/{userId}
     * @allow (create) - Authenticated user with UID 'user123' can create their profile at /users/user123 if request.auth.uid == 'user123'.
     * @allow (get) - Authenticated user with UID 'user123' can read their profile at /users/user123.
     * @allow (update) - Authenticated user with UID 'user123' can update their profile at /users/user123.
     * @allow (delete) - Authenticated user with UID 'user123' can delete their profile at /users/user123.
     * @deny (create) - Authenticated user with UID 'user456' cannot create a profile at /users/user123.
     * @deny (get) - Authenticated user with UID 'user456' cannot read the profile at /users/user123.
     * @deny (update) - Authenticated user with UID 'user456' cannot update the profile at /users/user123.
     * @deny (delete) - Authenticated user with UID 'user456' cannot delete the profile at /users/user123.
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId} {
      // Reads
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;

      // Writes
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && resource.data.id == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Secures game sessions, allowing the organizer to manage them.
     * @path /gameSessions/{gameSessionId}
     * @allow (create) - Authenticated user with UID 'user123' can create a game session if request.resource.data.organizerId == 'user123'.
     * @allow (get) - Any authenticated user can read game session details.
     * @allow (update) - Authenticated user with UID 'user123' can update a game session if they are the organizer (resource.data.organizerId == 'user123').
     * @allow (delete) - Authenticated user with UID 'user123' can delete a game session if they are the organizer (resource.data.organizerId == 'user123').
     * @deny (create) - Authenticated user with UID 'user456' cannot create a game session with organizerId set to 'user123'.
     * @deny (update) - Authenticated user with UID 'user456' cannot update a game session organized by 'user123'.
     * @deny (delete) - Authenticated user with UID 'user456' cannot delete a game session organized by 'user123'.
     * @principle Enforces document ownership for writes based on the 'organizerId' field and allows public reads.
     */
    match /gameSessions/{gameSessionId} {
      // Reads
      allow get: if true;
      allow list: if true;

      // Writes
      allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwnerOfGameSession(resource.data.organizerId);
      allow delete: if isSignedIn() && isExistingOwnerOfGameSession(resource.data.organizerId);
    }

    /**
     * @description Allows public read access to court information.
     * @path /courts/{courtId}
     * @allow (get) - Any user, authenticated or not, can read court details.
     * @allow (list) - Any user, authenticated or not, can list courts.
     * @deny (create) - No one can create courts (TODO).
     * @deny (update) - No one can update courts (TODO).
     * @deny (delete) - No one can delete courts (TODO).
     * @principle Allows public reads but restricts writes.
     */
    match /courts/{courtId} {
      // Reads
      allow get: if true;
      allow list: if true;

      // Writes
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Secures groups, allowing only members to access them.
     * @path /groups/{groupId}
     * @allow (create) - Authenticated user can create a group.
     * @allow (get) - Authenticated user can read a group if they are a member.
     * @allow (list) - Authenticated user can list groups.
     * @allow (update) - Authenticated user can update a group if they are a member.
     * @allow (delete) - Authenticated user can delete a group if they are a member.
     * @deny (get) - Authenticated user cannot read a group if they are not a member.
     * @deny (update) - Authenticated user cannot update a group if they are not a member.
     * @deny (delete) - Authenticated user cannot delete a group if they are not a member.
     * @principle Enforces group membership for access.
     */
    match /groups/{groupId} {
      // Reads
      allow get: if isSignedIn() && isMember(resource.data.memberIds);
      allow list: if isSignedIn();

      // Writes
      allow create: if isSignedIn();
      allow update: if isSignedIn() && isExistingMember(resource.data.memberIds);
      allow delete: if isSignedIn() && isExistingMember(resource.data.memberIds);
    }

  }

  // --- Helper functions ---

  /**
   * @description Checks if the user is signed in.
   * @return True if the user is signed in, false otherwise.
   */
  function isSignedIn() {
    return request.auth != null;
  }

  /**
   * @description Checks if the user is the owner of the resource.
   * @param userId The user ID to compare against the authenticated user's UID.
   * @return True if the user is the owner, false otherwise.
   */
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  /**
   * @description Checks if the user is the existing owner of the resource (exists and is owned by the user).
   * @param userId The user ID to compare against the authenticated user's UID.
   * @return True if the user is the owner and the resource exists, false otherwise.
   */
  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }

  /**
   * @description Checks if the user is the existing organizer of the game session.
   * @param organizerId The organizer ID to compare against the authenticated user's UID.
   * @return True if the user is the organizer and the resource exists, false otherwise.
   */
  function isExistingOwnerOfGameSession(organizerId) {
    return request.auth.uid == organizerId && resource != null;
  }

  /**
   * @description Checks if the user is a member of the group.
   * @param memberIds An array of user IDs representing the group members.
   * @return True if the user is a member, false otherwise.
   */
  function isMember(memberIds) {
    return isSignedIn() && memberIds is list && request.auth.uid in memberIds;
  }

   /**
   * @description Checks if the user is a member of the group, and the group exists
   * @param memberIds An array of user IDs representing the group members.
   * @return True if the user is a member, false otherwise.
   */
  function isExistingMember(memberIds) {
    return isMember(memberIds) && resource != null;
  }
}