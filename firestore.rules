/**
 * @fileoverview Firestore Security Rules for the LocalDink application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles
 * and uses denormalized data for authorization in other collections.
 * It prioritizes security and avoids complex `get()` calls for efficiency.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data, owned by the user with matching UID.
 * - /gameSessions/{gameSessionId}: Stores game session data, with denormalized organizerId.
 * - /courts/{courtId}: Stores court data, publicly readable.
 * - /groups/{groupId}: Stores group data, access controlled by member list.
 *
 * Key Security Decisions:
 * - User profiles are strictly owned and managed by the authenticated user.
 * - Game sessions are managed by the organizer (organizerId field).
 * - Courts are publicly readable.
 * - Listing of the users collection is disabled to prevent information disclosure.
 *
 * Denormalization for Authorization:
 * - GameSession documents contain the organizerId, allowing rules to check ownership
 *   without additional reads.
 *
 * Structural Segregation:
 * - No segregation is present in this data model.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces user-ownership for user profiles. Only the authenticated user
     *              can read, update, or delete their own profile.
     * @path /users/{userId}
     * @allow (get) User with UID 'user_abc' can read their own profile.
     *        Request: auth.uid = 'user_abc'
     * @allow (create) User with UID 'user_abc' can create their own profile.
     *        Request: auth.uid = 'user_abc', request.resource.data.id = 'user_abc'
     * @allow (update) User with UID 'user_abc' can update their own profile.
     *        Request: auth.uid = 'user_abc', resource.data.id = 'user_abc'
     * @allow (delete) User with UID 'user_abc' can delete their own profile.
     *        Request: auth.uid = 'user_abc', resource.data.id = 'user_abc'
     * @deny  (get) User with UID 'user_xyz' cannot read user profile 'user_abc'.
     *        Request: auth.uid = 'user_xyz'
     * @deny  (create) User with UID 'user_xyz' cannot create user profile 'user_abc'.
     *        Request: auth.uid = 'user_xyz', request.resource.data.id = 'user_abc'
     * @principle Enforces document ownership for writes and prevents unauthorized access.
     */
    match /users/{userId} {
      // Read rules
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false; // block blind lists

      // Write rules
      allow create: if isSignedIn() && isSelfCreation(userId);
      allow update: if isSignedIn() && isExistingOwner(userId) && isOwnerIdImmutable();
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to game session documents. Only the organizer can
     *              create, update, or delete game sessions. Anyone can read.
     * @path /gameSessions/{gameSessionId}
     * @allow (get) Any user can read a game session.
     *        Request: any auth.uid
     * @allow (list) Any user can list game sessions.
     *        Request: any auth.uid
     * @allow (create) User with UID 'user_abc' can create a game session with organizerId 'user_abc'.
     *        Request: auth.uid = 'user_abc', request.resource.data.organizerId = 'user_abc'
     * @allow (update) User with UID 'user_abc' can update a game session they organize.
     *        Request: auth.uid = 'user_abc', resource.data.organizerId = 'user_abc'
     * @allow (delete) User with UID 'user_abc' can delete a game session they organize.
     *        Request: auth.uid = 'user_abc', resource.data.organizerId = 'user_abc'
     * @deny  (create) User with UID 'user_xyz' cannot create a game session with organizerId 'user_abc'.
     *        Request: auth.uid = 'user_xyz', request.resource.data.organizerId = 'user_abc'
     * @principle Enforces organizer-only write access based on denormalized organizerId field.
     */
    match /gameSessions/{gameSessionId} {
      // Read rules
      allow get, list: if true;

      // Write rules
      allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOrganizer();
      allow delete: if isSignedIn() && isExistingOrganizer();
    }

    /**
     * @description Allows public read access to court documents.
     * @path /courts/{courtId}
     * @allow (get) Any user can read court data.
     *        Request: any auth.uid
     * @allow (list) Any user can list court data.
     *        Request: any auth.uid
     * @deny (create) No one can create court documents.
     * @deny (update) No one can update court documents.
     * @deny (delete) No one can delete court documents.
     * @principle Allows public read access.
     */
    match /courts/{courtId} {
      // Read rules
      allow get, list: if true;

      // Write rules
      allow create, update, delete: if false;
    }

    /**
     * @description Controls access to group documents based on group membership.
     *              Members can read group data.  No one can create, update or delete.
     * @path /groups/{groupId}
     * @allow (get) User with UID 'user_abc' can read group 'group_123' if they are a member.
     *        Request: auth.uid = 'user_abc', resource.data.memberIds contains 'user_abc'
     * @allow (list) User with UID 'user_abc' can list group 'group_123' if they are a member.
     *        Request: auth.uid = 'user_abc', resource.data.memberIds contains 'user_abc'
     * @deny (create) No one can create group documents.
     * @deny (update) No one can update group documents.
     * @deny (delete) No one can delete group documents.
     * @principle Restricts read access to group members.
     */
    match /groups/{groupId} {
      // Read rules
      allow get, list: if isSignedIn() && isGroupMember();

      // Write rules
      allow create, update, delete: if false;
    }

    // ---- Helper functions ----

    // Checks if the user is signed in.
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the requesting user is the owner of the resource.
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Checks if the requesting user is creating their own user document.
    function isSelfCreation(userId) {
      return request.auth.uid == userId && request.resource.data.id == userId;
    }

    // Checks if the requesting user is the owner of an existing resource.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // Checks if the requesting user is the organizer of an existing game session.
    function isExistingOrganizer() {
      return request.auth.uid == resource.data.organizerId;
    }

    // Checks if the 'id' field is immutable on update.
    function isOwnerIdImmutable() {
      return resource.data.id == request.resource.data.id;
    }

    // Checks if the requesting user is a member of the group.
    function isGroupMember() {
      return request.auth.uid in resource.data.memberIds;
    }
  }
}